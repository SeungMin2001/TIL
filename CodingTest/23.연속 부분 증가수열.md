```cpp
#include<stdio.h>
int main(){
	int n,A[100000]={0,},max=-1,cnt=0,max_cnt=-1;
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d",&A[i]);
	}
	for(int i=0;i<n;i++){
		if(A[i]>=max){     //A[i]>=max면 cnt++ 즉 수열길이를 1 늘려준다.
			max=A[i];
			cnt++;
			if(max_cnt<cnt) max_cnt=cnt;     //cnt가 1씩 늘어날때마다 max_cnt와 비교해준다. 
		}
		if(A[i]<max){         //A[i]<max가 도;면 cnt=1로 바꿔준다. 지금까지의 수열은 끝났지만 A[i]부터 시작하는 수열을 측정하기 때문에
			cnt=1;              // 1부터 시작해줘야한다.
			max=A[i];           // 그리고 max도 A[i]로 초기화해준다. 왜냐하면 수열의 끝을 측정하는 코드가 max보다A[i]가 작을때 이기 때문에
		}                    // max=A[i](max=수열의 시작인덱스) 를 해줘야 다음 수열길이를 정확히 측정할수 있다.
	}
	printf("%d",max_cnt);
	return 0;
}
```
 
 ### 풀면서 느낀점 :
 ##### 이 문제도 10분정도 고민해서 나온 아이디어로 해결하였다.
 ##### A[i]가 max보다 크거나 같으면 cnt++을 해준다. 그리고 A[i]<max를 만나면 cnt=1로 초기화 해준다. 그리고 max=A[i]를 해준다.
 ##### 이렇게 해주면 연속 부분 증가수열을 구할수 있다. 
 ##### 다시보면 정말 어려운 알고리즘이였지만 내가 어떻게 이런 생각을 했지? 라는 생각이 든다.
 ##### 곰곰히 생각해보면 입력예제로 나온 수들을 보면서 예를 이렇게 해주면 수열길이가 5가 나오곘구나 하면서 알고리즘을 짯던것 같다.
 ##### 쉽지는 않은 문제였다. 그리고 구름IDE는 100000개의 케이스를 받지 못한다. 프로그램이 멈춰버린다.
 ##### 그래서  https://www.tutorialspoint.com/compile_cpp_online.php 컴파일러를 빌려서 하였다. 얘는 100000개의 케이스를 잘 받는다.
<br><br>
##### 다시 생각해보면 생각보다 쉬운 문제였다 ;;;;
##### 그냥 증가하거나 같으면 1씩 증가시키다가 감소하는 애를 만나면 1부터 다시 길이를 측정하면 풀리는 문제였다.
##### 그리고 실시간으로 max와 비교하면 끝;;; 쉬운 문제였다,,,, 쉬운문제..
