```cpp
#include<stdio.h>
int main(){
	int N,now,j,A[101]={0,};
	scanf("%d",&N);
	for(int i=0;i<N;i++) scanf("%d",&A[i]);
	for(int i=1;i<N;i++){
		now=A[i];             // 현재 원소
		for(j=i-1;j>=0;j--){   //현재 원소보다 큰게 있으면 뒤로 한칸씩 민다.
			if(now<A[j]) A[j+1]=A[j];
			else break;         //작은걸 만나면 break
		}
		A[j+1]=now;               //j가 의미하는건 A[j]가 now보다 작다는 점. 그리고 A[j] 다음 A[j+1]의 now가 들어가야 된다는점
	}                     
	for(int i=0;i<N;i++){
		printf("%d ",A[i]);
	}
	return 0;
}
```
### 풀면서 느낀점 :
##### 생각보다 어려웠다. 간단한건줄 알았지만 집적 구현해보니 쉽지 않았다.
##### 삽입알고리즘은 이렇다. 일단 두번째 원소부터 마지막 원소까지 진행된다.
##### 그리고 한 원소당 i-1부터 0까지 반복문이 도는데 그중 자기보다 큰원소가 있으면 그 원소부터 i까지 한칸씩 뒤로 밀려난다.
##### 그리고 자기보다 작은 원소를 만나면 break 된다. 그리고 그 break될때 j를 기억한 뒤
##### 그 멈췄던 인덱스보다 +1인 곳에 now를 저장하게 된다.
##### 즉 자기보다 큰게 있으면 하나씩 뒤로 밀고 작은걸 만나면 그때 작은거 바로 다음칸에 자기가 들어간다.
##### 이것이 삽입 알고리즘이다.
