```cpp
#include<stdio.h>
int main(){
	int S,N,A[101]={0,};
	scanf("%d %d",&S,&N);
	for(int i=0;i<N;i++){
		int data,index=S-1;
		scanf("%d",&data);
		for(int j=0;j<S;j++){ //0부터 S-1까지 돌면서 중복되는 값이 있으면 저장하는 작업
			if(data==A[j]){
				index=j;
				break;
			}
		}
                            // 만약 중복되는 값이 없으면 index는 S-1이 됨(7번줄 초기화 참고)
		for(int k=index-1;k>=0;k--){
			A[k+1]=A[k];              //0부터 index까지 한칸씩 밀고 첫번재의 data를 넣어줌
		}
		A[0]=data;
	}
	for(int i=0;i<S;i++) printf("%d ",A[i]);
	return 0;
}
```

### 풀면서 느낀점 :
##### 핵심 아이디어는 index변수가 핵심인데
##### N개 만큼 data를 받을때마다 A배열에 data가 원래 있는 값인지를 O(N) 만큼 돌면서 확인한다.
##### 만약 중복되는 값이 있다하면 그 값의 인덱스를 index의 넣어주고 없다 하면 index=S-1 즉 마지막 인덱스를 넣어준다.
##### 그다음 0부터 index까지 1칸씩 민다음 첫번째 원소의 data를 넣어주면 풀리는 문제이다.
##### 처음에는 엄청 복잡하고 시간복잡도도 많은 방법으로 코드를 짰지만 이건 아니다 싶어서 다시 풀어본 결과
##### 이런 아이디어를 생각할수 있었다. 따라서
##### 중복되는 값이 없으면 처음에 넣고 모든 원소를 1칸 뒤로 밀면 되는것이고 중복되는것이 있으면 0부터 중복된 원소까지만 1칸씩 밀고
##### 처음 원소에 data를 넣어주면 풀리는 문제였다.
