```cpp
#include<stdio.h>
int main(){
	int N,A[101]={0,},check[101]={0,};
	scanf("%d",&N);
	for(int i=1;i<=N;i++){
		scanf("%d",&A[i]);
		check[i]=i;
	}
	for(int i=N-1;i>=0;i--){   //뒤에서 바로 한칸 앞인 원소부터 1까지 도는 반복문
		for(int j=0;j<A[i];j++){  //A[i]만큼 도는 반복문 , 즉 자기보다 앞에있는 나보다 큰수의 개수들만큼 돈다.
			check[i+j]=check[i+j+1];  //i+j = i+j+1 ,즉 한칸씩 땡긴다.(j만큼==A[i]만큼)
		}
		check[A[i]+i]=i; //A[i]+i에 넣어주면 삽입한뒤 한칸 앞으로 땡긴 값들이 나온다.
	}
	for(int i=1;i<=N;i++) printf("%d ",check[i]);
	return 0;
}
```

### 풀면서 느낀점 :
##### 개인적으로 약간 어려웠던 문제였다.
##### 하지만 이것도 아이디어를 잘 생각해 내서 다행히 도움받지않고 풀었다.
##### 아이디어는 마지막 원소 바로 앞인 N-1부터 시작해 반복문을 돈다.
##### 그리고 입력받은 앞에 자기보다 큰 수의 개수만큼 뒤로 보낸다. 이게 성립되는 이유는 뒤에있는 원소들은 전부 자신보다 큰 수이기 때문이다.
##### 따라서 A배열은 자기 앞의 자기보다 큰 수들의 개수를 담았고 check배열은 답이 될 수열을 담은 배열이다.
##### 이렇게 check배열에 A배열에 저장되있는 수만큼 뒤로 보내면 정상적으로 풀린다.
##### 여기서 뒤로 보낼때 삽입정렬 원리처럼 땡겨줘야한다.
##### 떙겨줘야 하는 범위는 좀 잘 생각해야 구할수 있는데
##### 현재 원소인 i 부터 A[i]+i까지 이다. 그다음 check[i]=check[i+1]를 해주면 앞으로 땡겨지고 check[A[i]+i] 가 비게된다.
##### 그자리에 i를 넣어주면 떙겨진 효과를 보게된다.

### 여기서의 포인트는 N-1부터 시작해 1까지 도는 방법이였다.  그리고 이 방법을 쓴 이유를 아는게 포인트다.
##### 이유는 check배열을 초기화할때 연속적인 오름차순으로 값을 집어넣었다.
##### 따라서 i 뒤에 있는 원소들은 무조건 check[i]보다 큰 수들이다. 
##### 그래서 A[i]만큼 뒤로 보내는 근거가 된다.
