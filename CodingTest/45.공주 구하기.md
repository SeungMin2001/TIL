```cpp
#include<stdio.h>
int main(){
	int N,K,A[1001]={0,},cnt,key,count=0;
	scanf("%d %d",&N,&K);
	for(auto i=1;i<=N;i++) A[i]=i;
	cnt=1;key=1;
	while(count!=N-1){  //닶을 0으로 바꾸는 작업을 N-1까지만 하게되면 남는 원소가 답이되기 때문에 N-1까지 돌린다.
		//printf("%d %d %d\n",cnt,key,count);
		if(A[cnt]==0){  //값이 0이면 점프
			cnt++;
			if(cnt==N+1) cnt=1;  //N을 넘어가면 1로 돌려놓기
			continue;
		}
		if(key==K){   //K번쩨를 찾았으면 그 값을 0으로 해주고 다시 cnt++
			A[cnt]=0;
			key=1;
			cnt++;
			if(cnt==N+1) cnt=1;
			count++;
			continue;
		}
		cnt++;
		if(cnt==N+1) cnt=1;    //N을 넘어가면 다시 1로 돌려놓기
		key++;
	}
	for(int i=1;i<=N;i++){  //한 원소 빼고 다 0으로 초기화 됨. 따라서 0이 아닌값을 찾으면 그게 답이됨
		if(A[i]!=0){
			printf("%d",A[i]);
			return 0;
		}
	}
	return 0;
}
```
### 풀면서 느낀점 :
##### 이 문제는 처음에 봤을때 쉬울것 같은데? 라고 생각했다가 생각보다 어려웠던 문제다 ㅋㅋ
##### 처음엔 vecotr로 받은다음 v.erase()로 원소삭제 해주고 v.size()==1이 될때가지 돌릴려 했는데
##### 알수없는 오류가 나왔고 끝까지 알아내지 못했다,
##### 그래서 배열로 잡고 풀었다. 근데 원소가 1개가 남아야 하는데 게속 2개가 남는것이였다.
##### 그래서 이 문제로 10분동안 고생하다가 결국 찾아내서 풀었다.
##### 문제는 값이 0인 애를 찾았을때 cnt++를 해줬는데 여기서 cnt==N+1 cnt=1를 해줘야 했던 것이다.
##### 저걸 안해줘서 1001까지 값이 0인 배열이다보니 끝까지 간 모양이다....
##### 그래서 저걸 고쳐주니 풀렸다.
