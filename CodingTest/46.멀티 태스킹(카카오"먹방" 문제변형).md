```cpp
#include<stdio.h>
int main(){
	int N,K,A[2001]={0,},cnt=0,key=0,c=0,index=0;
	scanf("%d",&N);
	for(int i=0;i<N;i++) scanf("%d",&A[i]);
	scanf("%d",&K);
	while(cnt!=K){   //cnt==K가 될때까지 도는거
		if(A[c]==0){  //값이 0이 되는거 찾았을때 c는 +1해주고 c==N이면 0 만들어주고 
			c++;        //여기서 key값의 역할은 모두가 0이 됬을때 무한반복이 될수 있기 때문에 걸어둔 안전장치이다.
			if(c==N){  
				c=0;
				if(key==0){
					printf("-1");
					return 0;
				}
				key=0;
			}
		}
		else{
			A[c]--; //값이 0이 아닌걸 찾았을때 거기에 -1를 해준다.
			key=1;
			c++;
			cnt++;
			if(c==N){
				c=0;
				if(key==0){  //안전장치
					printf("-1");
					return 0;
				}
				key=0;
			}
			index=c;  끝날때 c를 기억하는 index (끝날때 도는 반복문에 index는 다음원소부터 돌아야 하므로 c++을 하고나서 index에 저장한다.)
      }
	}
	for(int i=0;i<N;i++){ //index부터 시작해서 한바퀴를 돈다(N만큼)
		if(A[index]!=0){   //값이 0이 아닌걸 찾으면 출력하고 끝
			printf("%d",index+1);
			return 0;
		}
		else index++;  
	}
	printf("-1");   //값이 다 0이면 작업할게 없으므로 -1출력
	return 0;
}
```

### 풀면서 느낀점 :
##### 확실히 난이도가 있었다. 한 3,40분 고민한거 같다.
##### 결국 포기하고 강의를 볼려고 한 순간 강의 처음부분에 전문제와 같은방식으로 풀면 된다. 라는 말을 듣고
##### 다시 도잔해서 맟춘 문제이다. 분명 전문제와 같은 방식으로 이미 여러번 해봤지만 안됐었는데
##### 뭔가 확신을 갖고 할때 힘이 있는것 같다.
##### 이 문제는 이전문제처럼 그냥 반복문 돌리면서 0이면 c++만 해주고 
##### 0이 아닐땐 -1해주고 넘어가준다. 그리고 c==N이 되면 c=0을 해줌으로써 사이클을 돌아준다.
##### 그리고 -1 해줄때마다 index에 저장한다 이 이유는 마지막으로 끝나는 인덱스가 몇번인지 기억하기 위해
##### 반복문이 끝난 다음에는 또 다른 반복문을 시작하는데 이 반복문은 끝난 index부터 1바퀴를 더 도는 반복문이다.
##### 이 이유는 오름차순으로 주어진 데이터가 아니기 때문에 꼭 마지막 원소가 0이 된다고 모든 원소가 0이 되는게 아니다.
##### 즉 K번을 돌았을때 이런 상황이 일어날수 있다는 거다. => 0,0,0,1,0,1
##### 저럴때 6번째에서 0을 만들고 끝나도 4번째에 1이 남아있기 때문에 답은 4번째가 된다.
##### 이런 예외처리를 해주는게 N번 한바퀴를 도는 반복문을 마지막에 넣는것이다.
##### 반복문을 돌면서 0이 아닌값을 찾으면 출력하고 한바퀴를 다 돌았는데도 값이 다 0이면 -1을 출력한다.
##### 이때 중요한건 마지막 반복문을 돌때 index부터 출발해야 한다는 점이다.
