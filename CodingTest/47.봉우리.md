```cpp
#include<stdio.h>
int main(){
	int N,A[52][52]={0,},cnt=0,X[4]={1,-1,0,0},Y[4]={0,0,1,-1};
	scanf("%d",&N);
	for(int i=1;i<=N;i++){
		for(int j=1;j<=N;j++){  //1,1부터 넣어줘야 인덱스 침범을 안함(0보다 작거나 50보다 큰 경우를 말함)
			scanf("%d",&A[i][j]);
		}
	}
	for(int i=1;i<=N;i++){
		for(int j=1;j<=N;j++){
			int key=0;   //key값은 항상 초기화 해줘야함
			for(int k=0;k<4;k++){    //상하좌우 좌표들
				if(A[i][j]>A[i+X[k]][j+Y[k]]) key++; //자기가 더 크면 +1
			}
			if(key==4) cnt++; 4개 다 자기가 더 크면 cnt+1
		}
	}
	printf("%d",cnt);
	return 0;
}
```
### 풀면서 느낀점 :
##### 쉽게 풀린 문제였다.
##### 그냥 모든 경우의 수를 계산하면 풀리는 문제
##### N*N개의 원소를 돌면서 하나씩 상하좌우 원소와 비교해 cnt를 늘리면 풀리는 문제
##### 여기서 주의해야 할점이 A의 크기를 50,50으로 잡아버리면 상하좌우를 비교할때
##### 0보다 작은 인덱스와 50보다 큰 인덱스를 참조할수가 있는데 이러면 오류가 난다.
##### 따라서 A의 크기를 52,52로 잡아주고 입력받을때 (1,1) 부터 넣어주면 인덱스 침범을 안하게 된다.

