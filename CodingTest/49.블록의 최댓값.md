```cpp
#include<stdio.h>
int main(){
	int N,A[10][10]={0,},sum=0;
	scanf("%d",&N);
	for(int i=0;i<N;i++){
		int data;
		scanf("%d",&data);
		for(int j=0;j<N;j++){//정면 데이터 => 모든 열을 같은값으로 초기화
			A[j][i]=data;
		}
	}
	for(int i=0;i<N;i++){ //우측 데이터 => 자기보다 큰애들만 자기랑 같은값으로 바꿔준다.
		int data;
		scanf("%d",&data);
		for(int j=0;j<N;j++){
			if(A[N-i-1][j]>data){
				A[N-i-1][j]=data;
			}
		}
	}
	for(int i=0;i<N;i++){
		for(int j=0;j<N;j++){
			sum=sum+A[i][j];      //배열의 모든원소의 합을 구하고 출력하면 끝
		}
	}
	printf("%d",sum);
	return 0;
}
```
### 풀면서 느낀점 :
##### 조금만 생각하면 쉽게 풀리는 문제였다.
##### 핵심은 정면에서 본 데이터들을 배열에 넣을때 열을 모두 같은 값으로 초기화 하는것이다.
##### 왜냐하면 최대 개수를 출력하라 했은니
##### 그다음 오른쪽 측면에서 본 데이터들이 들어오면 거기에 맞는 행을 전부 비교하는데
##### 비교할때 자기보다 큰 수들은 자기와 같게 바꿔주고 자기보다 작거나 같은 수들은 넘어가준다.
##### 그러면 블록의 최대개수를 구할수 있다.
##### 이 원리는 정면,우측면에서 본 블록의 높이가 같으면 놔두고 자기보다 큰애가 있으면 자기랑 높이만 맟춰주면
##### 조건 충족되기 때문이다.
