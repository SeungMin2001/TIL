```cpp
#include<stdio.h>
int N,A[11]={0,};
int dfs(int level){
	if(level==N+1){
		for(int i=1;i<level;i++){ //1로 체크된것 즉 숫자가 들어간것만 출력
			if(A[i]==1) printf("%d ",i);
		}
		printf("\n");
		return 0;
	}
	A[level]=1;    //level 숫자가 A[level]에 들어다는 의미
	dfs(level+1);
	A[level]=0;   //level 숫자가 A[level]에 안들어다는 의미
	dfs(level+1);
	return 0;
}
int main(){
	scanf("%d",&N);
	dfs(1);
	return 0;
}
```
### 풀면서 느낀점 :
##### 하,,, 혼자 힘으로 못풀었다,.. 결국 강의에 도움을 받았는데
##### 여기서 나의 치명적인 실수는 dfs를 실행할때 level,즉 길이에 초점을 둬서 풀려고 했던 것이다.
##### 3개가 들어간 부분집합 구하고 2개가 들어간 부분집합 구하고... 이러니 안풀리지
##### 이번 문제는 좀 색다르게 접근했어야 했다,
##### 1~N까지 숫자가 돌때 이 숫자가 부분집합에 들어가냐 안들어가냐 이 두가지를 놓고 dfs를 돌리면 풀린다.
##### 그래서 12줄부터 15줄을 보면 A[level]=1을 주고 다음level로 dfs를 돌린다.
##### 그다음 아랫줄에는 A[level]=0을 주고 dfs를 돌린다. 이렇게 코드를 짜면 
##### 경우의 수는 2^N이 나온다. 그리고 모든 부분집합의 경우의 수가 나온다.
##### 이제 0과1로 들어가는지 안들어가는지를 구분했다면 level==N+1이 되는 순간 1로 체크된거는 i를 출력해주면 된다.
##### 여기서 N+1인 이유는 level=1부터 시작했기 때문이다.
