```cpp
#include<stdio.h>
int N,M,A[11]={0,},B[11]={0,},cnt=0;
int dfs(int level,int sum){
	if(level==N){
		if(sum==M) cnt++;   //dfs를 N깊이까지 다 돌렸을때 sum이 M과 같다면 cnt+1를 해줌
		return 0;
	}
	A[level]=B[level];      //+를 붙혀서 dfs, -를 붙혀서 dfs, 안쓴다는 뜻으로 -1을 넣어서 dfs 각각 돌리는 작업
	dfs(level+1,sum+B[level]);
	A[level]=(B[level]*-1);
	dfs(level+1,sum+(B[level]*-1));
	A[level]=-1;
	dfs(level+1,sum);
	return 0;
}
int main(){
	scanf("%d %d",&N,&M);
	for(int i=0;i<N;i++) scanf("%d",&B[i]);
	dfs(0,0);
	printf("%d",cnt);
	return 0;
}
```

### 풀면서 느낀점 :
##### 저번 문제에서 사용한 아이디어를 떠올리기만 해도 쉽게 풀수 있었던 문제
##### 뭔가 느꼇던걸 쓰자면 이 아이디어를 생각하지 못한 옜날에 나였다면 몇시간을 투자해도 코드만 길어지고 풀지 못했을것 같다.
##### 근데 이 이아디어를 배우고 난 뒤에 이러한 문제의 유형들은 다 풀수 있을것 같다는 자신감이 생겼다.
##### 그런 의미에서 아이디어를 간단하게 한번더 기록해보자면 단순하다. 그냥 이 수가 들어가냐 안들어가냐 이 두가지를 놓고
##### dfs돌리면 끝이다. 그대신 계산수는 2^N이 되기때문에 시간복잡도를 생각하면서 써야한다.
##### 이번문제도 이 아이디어를 사용하는 문제였다.
##### 이번문제는 특별하게 +,-가 추가된 문제이다.
##### 하지만 별거 없다. B[level]에 +1를 곱해서 dfs돌리고 -1곱해서 dfs돌리고 넣지않는 -1를 넣어서 dfs를 돌리면 된다.
##### 따라서 이 문제는 3^N 시간복잡도를 갖는다. N이 10 이하라고 했으므로 시간복잡도는 3^10이라고 볼수있다. 대략 5만이 나온다.

