```cpp
#include<stdio.h>
int n,r,A[21][21];
int dfs(int n,int r){
	if(n==r||r==0||n==1) return 1;
	if(A[n][r]==0){
		return A[n][r]=dfs(n-1,r-1)+dfs(n-1,r);
	}
	return A[n][r];
}
int main(){
	scanf("%d %d",&n,&r);
	printf("%d",dfs(n,r));
	return 0;
}
```

### 풀면서 느낀점 :
##### 이 문제를 처음 접했을때 배열의 모든 팩토리얼의 값을 저장하려했었다,
##### 하지만 바보같은 생각이였다. 범위가 너무 컸기 때문이다.
##### 따라서 다른 방법이 필요했다, 강의를 보고 배운 아이디어이다,.
##### 조합(nCr)에서 원소 한개를 미리 정해놓고 접근하면 쉬워진다.
##### 한개를 미리 정했으니 n-1개 중 r-1개를 고르는 n-1Cr-1 + 골른 원소가 부분집합에 안들어간다는 가정을 해서
##### n-1개 중 r개를 고르는 n-1Cr 이렇게 두개를 더하면 같은값이 나온다.
##### 이러한 점화식을 갖고 재귀를 돌리는것이다. 리턴값이 1이 될때까지
##### 1이 되는 조건은 n==r이 되거나 r==0이 되면 1이된다.
##### 이 식은 꼮 기억하자!! <nCr = (n-1)C(r-1) + (n-1)Cr>
