```cpp
#include<stdio.h>
#include<math.h>
using namespace std;
int n,A[22][22],dp[22][22];
int main(){
	scanf("%d",&n);
	int data;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			scanf("%d",&A[i][j]);
		}
	}
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(A[i][j-1]==0) dp[i][j]=dp[i][j]+dp[i-1][j]+A[i][j]; //0이라는 뜻은 좌표범위를 벗어났다는 뜻. 
			else if(A[i-1][j]==0) dp[i][j]=dp[i][j]+dp[i][j-1]+A[i][j];
			else dp[i][j]=dp[i][j]+min(dp[i-1][j],dp[i][j-1])+A[i][j];//두 좌표에서 올수있는 좌표, 둘중 최솟값을 가중해주면 됨
		}
	}
	printf("%d",dp[n][n]);
	return 0;
}
```
### 풀면서 느낀점 :
##### 난 처음에 접근할때 1,1부터 가면서 오른쪽과 아래중 작은값으로 가면 된다고 생각했다,
##### 하지만 여기에는 함정이 있었다. 꼭 작은값으로 안가도 최솟값이 나올수 있는것이다.
##### 따라서 생각의 전환이 필요하다.
##### 1,1부터 시작하는게 아니라 좌표로 오는 경로중 최소경로를 저장하는 방식으로 가야한다. 무슨말이냐
#####  이중포문으로 모든좌표를 방문한다, 그리고 i,j에 들어갈 값은 i-1,j , i,j-1 두 좌표에서 올수 있는데
##### 두 좌표중 최솟값을 선택해서 dp배열에 가중해줘야 한다. 그래서 dp테이블을 완성한뒤 dp[n][n]을 출력하면 끝
##### 강의에서는 가장자리 처리를 미리 해주고 들어간다 내 코드와의 차이는 나는 2중포문을 돌면서 즉각으로 처리한다는 점이다.
