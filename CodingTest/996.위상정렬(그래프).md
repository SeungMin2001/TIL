```cpp
#include<stdio.h>
#include<queue>
#include<vector>
using namespace std;
int main(){
	int n,m,check[50]={0,};
	vector<int> v[51];
	queue<int> q;
	scanf("%d %d",&n,&m);
	for(int i=0;i<m;i++){
		int a,b;
		scanf("%d %d",&a,&b);
		v[a].push_back(b);
		check[b]++;  //b노드에 몇개의 노드가 오는지
	}
	for(int i=1;i<=n;i++){
		if(check[i]==0) q.push(i); //아무도 안오는 노드를 큐에 넣어준다(출발점)
	}
	while(!q.empty()){//bfs
		int node=q.front();
		printf("%d ",q.front());
		q.pop();
		for(int i=0;i<v[node].size();i++){//출발노드로부터 연결된 모든 노드를 들른다.
			check[v[node][i]]--;            //도착지점 노드에 체크배열의 값을 -1해준다
			if(check[v[node][i]]==0) q.push(v[node][i]);//만약 0이되면 큐에 넣어준다. (출발할수 있다는 뜻 0)
		}
	}
	return 0;
}
```
### 풀면서 느낀점 :
##### 위상정렬을 처음 배웠다. 생각보다 쉬웠다.
##### 위상정렬의 개념은 방향이 있는 그래프가 주어졌을때 방향으 무시하지 않으면서 순서대로 출력하는 알고리즘이다.
##### 한마디로 어떻게 하면 모든 노드를 출력하는데 그 순서가 방향을 틀리지 않고 다 출력하느냐 이다.
##### 각각의 일의 선후관계가 복잡하게 얽혀있을 때 각각 일의 선후관계를 유지하면서 전체 일의 순서를 짜는 알고리즘이다.
##### 이 알고리즘은 큐를 사용한다. 처음에 데이터를 받을때 자기한테 오는 노드들을 저장해놓아야 한다.
##### 그래서 check배열을 만들어주고 만약 1->5번 노드로 온다하면 check[5]++해주면 된다. 그러면 최종적으로 자기에게 몇개의 노드가 왔는지를 저장할수 있다,.
##### 그런 다음 check배열에 값중 0인 애들을 큐에 다 넣어준다. 
##### 그리고 bfs를 돌린다, 큐가 빌때까지 돌리고 q.front랑 연결된 애들을 다 큐에 넣어주는데 여기서 조건이 있다.
##### 만약 q.front가 1이면 1이 다른노드로 갈때 그 도착지점 노드에 check배열값을 --해준다. 그리고 check도착지점 노드가 0이 되면 큐에 넣어준다.
##### 그리고 q.front를 출력을 해주면 순서가 출력이 된다.
