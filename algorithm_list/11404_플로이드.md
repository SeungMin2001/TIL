```cpp
#include<stdio.h>
#include<vector>
#include<cmath>
#include<limits.h>
using namespace std;
int main(){
	int n,t,A[101][101]={0,};
	scanf("%d %d",&n,&t);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==j) A[i][j]=0;
			else A[i][j]=10000000; //100000*100 을 해줌(노드 * 최대자연수의 값)
		}
	}
	for(int i=1;i<=t;i++){
		int a,b,c;
		scanf("%d %d %d",&a,&b,&c);
		A[a][b]=min(A[a][b],c);
	}
	for(int i=1;i<=n;i++){
		
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				
				A[j][k]=min(A[j][k],A[j][i]+A[i][k]);//핵심코드 . 기존값vsi를 거쳐서 간 비용
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(A[i][j]>=10000000) A[i][j]=0;//100000*100 을 해줌
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			printf("%d ",A[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```

###  풀면서 느낀점 :
##### 그냥 플로이드-워샬 알고리즘을 아는지를 묻는 문제였다.
##### 플로이드-워샬 알고리즘은 모든 정점에서 모든정점으로 가는 최소비용을 출력해주는 알고리즘이다.
##### 핵심 코드는 각각의 A[i][]j에 대해 기존값 A[i][j]와 A[i][k][k][j] 즉 중간 k를 거쳐간거랑 둘중 작은거를 업데이트 해나간다.
##### 단 이 문제에서 조건중 하나가 노드가 겹칠수 있다는 점이다. 예를들어 i에서 j로 가는데 10비용이 드는 간선도 있지만 15비용이 드는
##### 간선도 데이터로 줬다는 뜻이다. 그래서 더 작은값만 남게 코드를 짰고 또 최대값이 100000보다 작거나 같은 자연수라 했다.
##### 그래서 100001 로 초기화를 했더니 틀렸다. 결국 100000*100 을 했더니 맞았다.
##### 그냥 노드에 개수*최대자연수를 한것같다. 왜그런진 자세히 이해하진못했으나 알아두자 ㅎ
