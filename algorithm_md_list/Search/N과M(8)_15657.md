```cpp
include<stdio.h>
#include<algorithm>
using namespace std;
int N,M,A[9]={0,},check[10001]={0,},B[10]={0,};
int dfs(int level){
	if(level==M){
		for(int i=1;i<M;i++){
			if(A[i]<A[i-1]) return 0;   //오름차순인 순열을 걸러주는 반복문
		}
		for(int i=0;i<M;i++){
			printf("%d ",A[i]);
		}
		printf("\n");
		return 0;
	}
	else{
		for(int i=0;i<N;i++){
			A[level]=B[i];
			dfs(level+1);
		}
	}
	return 0;
}
int main(){
	scanf("%d %d",&N,&M);
	for(int i=0;i<N;i++){
		scanf("%d",&B[i]);
	}
	sort(B,B+N);
	dfs(0);
	return 0;
}
```
### 풀면서 느낀점 : dfs를 이용해 경우의 수를 구하는 방법만 알고있으면 응용해서 쉽게 풀리는 문제
### 문제조건이 오름차순, 같은수를 여러번 골라도 된다 여서, check배열을 빼고 오름차순인 순열을 걸러주면 풀리는 문제
